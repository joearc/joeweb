<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mondrian Mosaic & Value Analyzer</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        :root {
            --mondrian-black: #1a1a1a;
            --mondrian-white: #e8e8e8;
            --mondrian-gray: #d0d0d0;
            --mondrian-border: 4px;
        }
        body {
            background-color: var(--mondrian-white);
            color: var(--mondrian-black);
            font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif;
            margin: 0;
            padding: 20px;
        }
        .canvas-container {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-bottom: 30px;
        }
        .canvas-box {
            border: var(--mondrian-border) solid var(--mondrian-black);
            overflow: hidden;
            background: #fff;
            box-shadow: 6px 6px 0px var(--mondrian-gray);
            position: relative;
        }
        .canvas-label {
            position: absolute;
            top: 0;
            left: 0;
            background: var(--mondrian-black);
            color: white;
            padding: 2px 10px;
            font-size: 10px;
            font-weight: bold;
            z-index: 10;
            letter-spacing: 1px;
        }
        canvas {
            width: 100%;
            height: auto;
            display: block;
            image-rendering: pixelated;
        }
        .color-group {
            border: var(--mondrian-border) solid var(--mondrian-black);
            padding: 8px;
            background: white;
            transition: transform 0.2s;
            box-shadow: 4px 4px 0px var(--mondrian-gray);
        }
        .color-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(20px, 1fr));
            gap: 2px;
        }
        .color-box {
            aspect-ratio: 1;
            border: 1px solid rgba(0,0,0,0.05);
        }
        #hueWheelContainer {
            position: relative;
            width: 380px;
            height: 380px;
            margin: 0 auto;
            border: var(--mondrian-border) solid var(--mondrian-black);
            background: white;
            padding: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 8px 8px 0px var(--mondrian-gray);
        }
        .dot {
            position: absolute;
            width: 8px;
            height: 8px;
            border: 1.5px solid var(--mondrian-black);
            border-radius: 50%;
            transform: translate(-50%, -50%);
            pointer-events: none;
            z-index: 10;
        }
        .controls {
            display: flex;
            gap: 15px;
            margin-bottom: 30px;
            justify-content: center;
            align-items: center;
        }
        #imageInput {
            display: none;
        }
        #uploadBtn {
            background: white;
            color: var(--mondrian-black);
            padding: 8px 24px;
            cursor: pointer;
            font-weight: bold;
            text-transform: uppercase;
            letter-spacing: 2px;
            border: var(--mondrian-border) solid var(--mondrian-black);
            transition: 0.2s;
            box-shadow: 4px 4px 0px var(--mondrian-gray);
        }
        #uploadBtn:hover {
            transform: translate(-1px, -1px);
            box-shadow: 5px 5px 0px var(--mondrian-black);
        }
        .custom-select {
            appearance: none;
            background: white;
            border: var(--mondrian-border) solid var(--mondrian-black);
            padding: 8px 30px 8px 15px;
            font-weight: bold;
            cursor: pointer;
            box-shadow: 4px 4px 0px var(--mondrian-gray);
            background-image: url("data:image/svg+xml;charset=UTF-8,%3Csvg xmlns='http://www.w3.org/2000/svg' width='24' height='24' viewBox='0 0 24 24' fill='none' stroke='black' stroke-width='3' stroke-linecap='round' stroke-linejoin='round'%3E%3Cpolyline points='6 9 12 15 18 9'%3E%3C/polyline%3E%3C/svg%3E");
            background-repeat: no-repeat;
            background-position: right 8px center;
            background-size: 14px;
        }
        #valueStatsPanel {
            background: white;
            border: var(--mondrian-border) solid var(--mondrian-black);
            padding: 15px;
            box-shadow: 6px 6px 0px var(--mondrian-gray);
            margin-bottom: 30px;
            display: none;
            text-align: center;
        }
        #overallValueText {
            font-size: 1.25rem;
            font-weight: 900;
            letter-spacing: 1px;
        }
        #errorMsg {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: #ff4444;
            color: white;
            padding: 8px 16px;
            border: 2px solid black;
            box-shadow: 4px 4px 0px #880000;
            display: none;
            z-index: 1000;
            font-weight: bold;
        }
    </style>
</head>
<body>

    <div id="errorMsg"></div>

    <div class="controls">
        <label id="uploadBtn" for="imageInput">上傳圖片</label>
        <input type="file" id="imageInput" accept="image/*">
        
        <select id="dimensionSelect" class="custom-select">
            <option value="1">1 x 1</option>
            <option value="2">2 x 2</option>
            <option value="4">4 x 4</option>
            <option value="8" selected>8 x 8</option>
            <option value="16">16 x 16</option>
            <option value="24">24 x 24</option>
        </select>
    </div>

    <div class="max-w-5xl mx-auto">
        
        <!-- 1. 原圖與馬賽克 -->
        <div class="canvas-container">
            <div class="canvas-box">
                <div class="canvas-label">SOURCE</div>
                <canvas id="sourceCanvas"></canvas>
            </div>
            <div class="canvas-box">
                <div class="canvas-label">MOSAIC</div>
                <canvas id="mosaicCanvas"></canvas>
            </div>
        </div>

        <!-- 2. 3階統計面板 -->
        <div id="valueStatsPanel">
            <div id="overallValueText">-- _ -- _ --</div>
            <div class="mt-2 flex justify-center gap-4 text-[10px] font-bold uppercase tracking-widest">
                <div class="flex items-center gap-1"><span class="w-3 h-3 bg-white border border-black"></span></div>
                <div class="flex items-center gap-1"><span class="w-3 h-3 bg-gray-400 border border-black"></span></div>
                <div class="flex items-center gap-1"><span class="w-3 h-3 bg-[#1b1b1b] border border-black"></span></div>
            </div>
        </div>

        <!-- 3. 色彩分組 -->
        <div id="cmykGroups" class="grid grid-cols-2 md:grid-cols-4 gap-4 mb-10"></div>

        <!-- 4. 色輪 -->
        <div class="py-10 bg-[#d8d8d8] border-t-2 border-black flex justify-center mb-10">
            <div id="hueWheelContainer">
                <canvas id="hueWheelCanvas" width="360" height="360"></canvas>
                <div id="dotsOverlay"></div>
            </div>
        </div>

        <!-- 5. 全色盤 -->
        <div id="fullPaletteSection" class="bg-white border-[4px] border-black p-4 shadow-[8px_8px_0px_#d0d0d0] mb-10">
            <div id="fullPaletteGrid" class="color-grid"></div>
        </div>

        <!-- 6. 原圖與明暗圖對比 (移至最底) -->
        <div id="comparisonSection" style="display:none;" class="mt-20 pt-10 border-t-4 border-black border-dashed">
            <div class="canvas-container">
                <div class="canvas-box">
                    <div class="canvas-label">ORIGINAL</div>
                    <canvas id="compOriginalCanvas"></canvas>
                </div>
                <div class="canvas-box">
                    <div class="canvas-label">VALUE</div>
                    <canvas id="compValueCanvas"></canvas>
                </div>
            </div>
        </div>

    </div>

    <script>
        const imageInput = document.getElementById('imageInput');
        const dimensionSelect = document.getElementById('dimensionSelect');
        const sourceCanvas = document.getElementById('sourceCanvas');
        const mosaicCanvas = document.getElementById('mosaicCanvas');
        const compOriginalCanvas = document.getElementById('compOriginalCanvas');
        const compValueCanvas = document.getElementById('compValueCanvas');
        const comparisonSection = document.getElementById('comparisonSection');
        const cmykGroupsContainer = document.getElementById('cmykGroups');
        const fullPaletteGrid = document.getElementById('fullPaletteGrid');
        const hueWheelCanvas = document.getElementById('hueWheelCanvas');
        const dotsOverlay = document.getElementById('dotsOverlay');
        const errorMsg = document.getElementById('errorMsg');
        const valueStatsPanel = document.getElementById('valueStatsPanel');
        const overallValueText = document.getElementById('overallValueText');

        let originalImage = null;

        window.onload = () => { drawHueWheel(); };

        function showError(text) {
            errorMsg.textContent = text;
            errorMsg.style.display = 'block';
            setTimeout(() => { errorMsg.style.display = 'none'; }, 3000);
        }

        imageInput.onchange = (e) => {
            const file = e.target.files[0];
            if (!file) return;
            const reader = new FileReader();
            reader.onload = (event) => {
                const img = new Image();
                img.onload = () => {
                    originalImage = img;
                    comparisonSection.style.display = 'block';
                    valueStatsPanel.style.display = 'block';
                    processAllAnalyses(); 
                };
                img.src = event.target.result;
            };
            reader.readAsDataURL(file);
        };

        dimensionSelect.onchange = () => { if (originalImage) processAllAnalyses(); };

        function processAllAnalyses() {
            processMosaicAnalysis();
            processValueAnalysis();
        }

        function rgbToCmyk(r, g, b) {
            let c = 1 - (r / 255), m = 1 - (g / 255), y = 1 - (b / 255);
            let k = Math.min(c, m, y);
            if (k === 1) return { c: 0, m: 0, y: 0, k: 1 };
            return { c: (c - k) / (1 - k), m: (m - k) / (1 - k), y: (y - k) / (1 - k), k };
        }

        function getLuminance(r, g, b) { return 0.299 * r + 0.587 * g + 0.114 * b; }
        function getSaturation(r, g, b) {
            const max = Math.max(r, g, b), min = Math.min(r, g, b);
            return max === 0 ? 0 : (max - min) / max;
        }
        function getHue(r, g, b) {
            r /= 255; g /= 255; b /= 255;
            const max = Math.max(r, g, b), min = Math.min(r, g, b);
            if (max === min) return 0;
            let h = max === r ? (g - b) / (max - min) : max === g ? 2 + (b - r) / (max - min) : 4 + (r - g) / (max - min);
            h *= 60; return h < 0 ? h + 360 : h;
        }

        function processMosaicAnalysis() {
            const dim = parseInt(dimensionSelect.value);
            const ctxS = sourceCanvas.getContext('2d');
            sourceCanvas.width = originalImage.width;
            sourceCanvas.height = originalImage.height;
            ctxS.drawImage(originalImage, 0, 0);

            const targetRes = analyzeGrid(originalImage, dim);
            renderMosaic(targetRes.blocks, dim);
            renderColorAnalysis(targetRes.blocks);
            renderFullPalette(targetRes.blocks);
        }

        function analyzeGrid(img, dim) {
            const temp = document.createElement('canvas');
            const tCtx = temp.getContext('2d');
            temp.width = dim; temp.height = dim;
            tCtx.drawImage(img, 0, 0, dim, dim);
            const data = tCtx.getImageData(0, 0, dim, dim).data;
            let blocks = [];
            for (let i = 0; i < data.length; i += 4) {
                const r = data[i], g = data[i+1], b = data[i+2];
                blocks.push({ r, g, b, lum: getLuminance(r, g, b), cmyk: rgbToCmyk(r, g, b) });
            }
            return { blocks, dim };
        }

        function renderMosaic(blocks, dim) {
            mosaicCanvas.width = originalImage.width;
            mosaicCanvas.height = originalImage.height;
            const ctx = mosaicCanvas.getContext('2d');
            const bW = mosaicCanvas.width / dim, bH = mosaicCanvas.height / dim;
            blocks.forEach((b, i) => {
                ctx.fillStyle = `rgb(${b.r},${b.g},${b.b})`;
                ctx.fillRect((i % dim) * bW, Math.floor(i / dim) * bH, bW + 0.5, bH + 0.5);
            });
        }

        function processValueAnalysis() {
            const w = originalImage.width, h = originalImage.height;
            compOriginalCanvas.width = w; compOriginalCanvas.height = h;
            compOriginalCanvas.getContext('2d').drawImage(originalImage, 0, 0);
            compValueCanvas.width = w; compValueCanvas.height = h;
            const ctx = compValueCanvas.getContext('2d');
            ctx.drawImage(originalImage, 0, 0, w, h);
            const imageData = ctx.getImageData(0, 0, w, h), d = imageData.data;
            const levels = { dark: 27, gray: 127, light: 255 }, counts = { dark: 0, gray: 0, light: 0 };
            for (let i = 0; i < d.length; i += 4) {
                const b = 0.299 * d[i] + 0.587 * d[i+1] + 0.114 * d[i+2];
                let val;
                if (b < 85) { val = levels.dark; counts.dark++; }
                else if (b < 170) { val = levels.gray; counts.gray++; }
                else { val = levels.light; counts.light++; }
                d[i] = d[i+1] = d[i+2] = val;
            }
            ctx.putImageData(imageData, 0, 0);
            const ratios = calculateRatios(counts, w * h);
            overallValueText.innerText = `${ratios[0]} _ ${ratios[1]} _ ${ratios[2]}`;
            
            const rows = 2, cols = 4, cellW = w / cols, cellH = h / rows;
            const mainSize = Math.max(14, Math.floor(w / 40));
            for (let r = 0; r < rows; r++) {
                for (let c = 0; c < cols; c++) {
                    const sx = Math.floor(c * cellW), sy = Math.floor(r * cellH);
                    const region = ctx.getImageData(sx, sy, Math.floor(cellW), Math.floor(cellH));
                    const rd = region.data, rc = { dark: 0, gray: 0, light: 0 };
                    for (let i = 0; i < rd.length; i += 4) {
                        if (rd[i] === levels.dark) rc.dark++;
                        else if (rd[i] === levels.gray) rc.gray++;
                        else rc.light++;
                    }
                    drawValueLabel(ctx, sx, sy, calculateRatios(rc, rd.length / 4), mainSize);
                }
            }
        }

        function drawValueLabel(ctx, sx, sy, ratios, size) {
            const padding = 10, x = sx + padding, y = sy + padding;
            ctx.font = `bold ${size}px monospace`;
            let tw = ctx.measureText(ratios.join(' _ ')).width;
            ctx.fillStyle = 'rgba(0,0,0,0.7)';
            ctx.fillRect(x, y, tw + 10, size + 8);
            ctx.fillStyle = 'white';
            ctx.textBaseline = 'top';
            ctx.fillText(ratios.join(' _ '), x + 5, y + 4);
        }

        function calculateRatios(counts, total) {
            let rl = (counts.light / total) * 10, rg = (counts.gray / total) * 10, rd = (counts.dark / total) * 10;
            rl = Math.round(rl * 10) / 10; rg = Math.round(rg * 10) / 10; rd = Math.round(rd * 10) / 10;
            return [rl.toFixed(1), rg.toFixed(1), rd.toFixed(1)];
        }

        function renderColorAnalysis(blocks) {
            cmykGroupsContainer.innerHTML = ''; dotsOverlay.innerHTML = '';
            const groups = { C: [], M: [], Y: [], K: [] };
            blocks.forEach(b => {
                const { c, m, y, k } = b.cmyk, max = Math.max(c, m, y, k);
                if (max === c) groups.C.push(b); else if (max === m) groups.M.push(b); else if (max === y) groups.Y.push(b); else groups.K.push(b);
                addDotOnWheel(b);
            });
            ['C', 'M', 'Y', 'K'].forEach(key => {
                const group = document.createElement('div'); group.className = 'color-group';
                const grid = document.createElement('div'); grid.className = 'color-grid';
                groups[key].sort((a, b) => b.lum - a.lum).forEach(b => {
                    const box = document.createElement('div'); box.className = 'color-box';
                    box.style.backgroundColor = `rgb(${b.r},${b.g},${b.b})`; grid.appendChild(box);
                });
                group.appendChild(grid); cmykGroupsContainer.appendChild(group);
            });
        }

        function renderFullPalette(blocks) {
            fullPaletteGrid.innerHTML = '';
            [...blocks].sort((a, b) => b.lum - a.lum).forEach(b => {
                const box = document.createElement('div'); box.className = 'color-box';
                box.style.backgroundColor = `rgb(${b.r},${b.g},${b.b})`; fullPaletteGrid.appendChild(box);
            });
        }

        function drawHueWheel() {
            const ctx = hueWheelCanvas.getContext('2d'), cx = 180, cy = 180, r = 160;
            for (let a = 0; a < 360; a += 0.5) {
                const grad = ctx.createRadialGradient(cx, cy, 0, cx, cy, r);
                grad.addColorStop(0, '#808080'); grad.addColorStop(1, `hsl(${a}, 100%, 50%)`);
                ctx.beginPath(); ctx.moveTo(cx, cy); ctx.arc(cx, cy, r, (a-0.6)*Math.PI/180, (a+0.6)*Math.PI/180);
                ctx.fillStyle = grad; ctx.fill();
            }
        }

        function addDotOnWheel(b) {
            const h = getHue(b.r, b.g, b.b), s = getSaturation(b.r, b.g, b.b);
            const r = 160, cx = 180, cy = 180, d = s * r, rad = h * Math.PI / 180;
            const dot = document.createElement('div'); dot.className = 'dot';
            dot.style.left = `${cx + d * Math.cos(rad) + 10}px`; dot.style.top = `${cy + d * Math.sin(rad) + 10}px`;
            dot.style.backgroundColor = `rgb(${b.r},${b.g},${b.b})`; dotsOverlay.appendChild(dot);
        }
    </script>
</body>
</html>