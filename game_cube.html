<!DOCTYPE html>
<html lang="zh-Hant">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>小方塊大挑戰 - 記憶練習</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;600;800&display=swap');

        :root {
            --bg:        #1a1612;
            --surface:   #231e19;
            --border:    #3a3028;
            --muted:     #6b5e4e;
            --label:     #9e8c78;
            --text:      #e8ddd0;
            --accent:    #c4a882;
            --accent-dk: #a0845e;
            --canvas-bg: #1a2e1a; 
        }

        body {
            font-family: 'Inter', 'PingFang TC', sans-serif;
            background-color: var(--bg);
            color: var(--text);
            overflow-x: hidden;
            touch-action: none;
            margin: 0;
            padding: 0;
        }

        .global-nav {
            width: 100%;
            background-color: var(--surface);
            padding: 0.75rem;
            border-bottom: 1px solid var(--border);
        }
        .global-nav ul {
            display: flex;
            justify-content: center;
            gap: 1.5rem;
            list-style: none;
        }
        .global-nav a {
            color: var(--label);
            text-decoration: none;
            font-size: 0.75rem;
            font-weight: 600;
        }

        #canvas-container {
            position: relative;
            width: 90vw;
            height: 90vw;
            max-width: 360px;
            max-height: 360px;
            margin: 1.5rem auto;
            border-radius: 2rem;
            background-color: var(--canvas-bg);
            border: 2px solid var(--border);
            box-shadow: 0 20px 50px rgba(0,0,0,0.5);
        }

        canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 10;
            border-radius: 1.8rem;
            display: block;
            touch-action: none;
        }

        #undoBtn {
            position: absolute;
            top: 12px;
            right: 12px;
            width: 40px;
            height: 40px;
            background-color: rgba(35, 30, 25, 0.8);
            color: var(--text);
            border: 1px solid var(--border);
            border-radius: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 20;
            pointer-events: auto;
            transition: all 0.2s;
        }
        #undoBtn:disabled {
            opacity: 0;
            pointer-events: none;
        }

        .ui-ignore {
            pointer-events: none !important;
        }

        .countdown {
            position: absolute;
            font-size: 8rem;
            color: var(--accent);
            opacity: 0.8;
            font-weight: 800;
            z-index: 5;
            text-shadow: 0 4px 20px rgba(0,0,0,0.3);
        }

        .controls-area {
            width: 100%;
            max-width: 360px;
            margin: 0 auto;
            padding: 0 1rem;
            text-align: center;
        }

        .btn-main {
            background-color: var(--accent-dk);
            color: var(--bg);
            font-weight: 800;
            border-radius: 1rem;
            padding: 1.25rem;
            width: 100%;
            transition: all 0.2s;
            text-transform: uppercase;
            letter-spacing: 0.1em;
        }
        .btn-main:active {
            transform: scale(0.98);
            background-color: var(--accent);
        }
    </style>
</head>
<body class="flex flex-col items-center min-h-screen">
<div id="nav"></div>
  <script>
  // nav 連結備援（Claude 預覽 / 離線時使用）
  const NAV_FALLBACK = `
    <nav class="global-nav">
      <ul>
        <li><a href="./index.html">首頁</a></li>
        <li><a href="./about.html">about me</a></li>
        <li><a href="game_colorMemory.html">ColorMatch</a></li>
        <li><a href="game_dot.html">點點記憶大挑戰</a></li>
        <li><a href="./art19.html">19世紀藝術家</a></li>
        <li><a href="./game1.html">小遊戲猜地名</a></li>
        <li><a href="./game_color.html">明暗色彩分析</a></li>
        <li><a href="./game_guessArt.html">小遊戲_猜藝術家</a></li>
      </ul>
    </nav>`;

  function initNav(html) {
    const navContainer = document.getElementById('nav');
    navContainer.innerHTML = html;
    const navEl = navContainer.querySelector('.global-nav');
    const ul = navContainer.querySelector('ul');
    if (!navEl || !ul) return;
    // 插入漢堡按鈕
    const inner = document.createElement('div');
    inner.className = 'nav-inner';
    inner.innerHTML = `
      <span class="nav-brand">MENU</span>
      <button class="nav-toggle" id="nav-toggle" aria-label="開啟選單">
        <span></span><span></span><span></span>
      </button>`;
    navEl.insertBefore(inner, ul);
    document.getElementById('nav-toggle').addEventListener('click', () => {
      ul.classList.toggle('open');
    });
  }

  fetch("./nav.html")
    .then(r => { if (!r.ok) throw new Error(); return r.text(); })
    .then(html => initNav(html))
    .catch(() => initNav(NAV_FALLBACK));
</script>
    <div class="w-full max-w-md px-4 py-4 flex flex-col items-center">
        <!-- 頂部資訊 -->
        <header class="w-full flex justify-between items-end mb-2 px-2">
            <div>
                <h1 class="text-xl font-black tracking-tight">小方塊<span class="text-[#c4a882]">大挑戰</span></h1>
                <!-- 修改處：更新靜態文字並使其持續顯示 -->
                <p id="status-text" class="text-[10px] uppercase font-bold tracking-widest text-[#9e8c78]">方塊畫的好.畫畫沒煩惱</p>
            </div>
            <div id="round-display" class="px-3 py-1 rounded-full text-[10px] border border-[#3a3028] bg-[#231e19] text-[#c4a882] font-mono">ROUND 1 / 5</div>
        </header>

        <!-- 畫布區域 -->
        <div id="canvas-container">
            <canvas id="gameCanvas"></canvas>
            
            <button id="undoBtn" class="hidden" disabled title="復原上一筆">
                <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3" stroke-linecap="round" stroke-linejoin="round"><path d="M3 10h10a8 8 0 0 1 8 8v2"></path><polyline points="9 14 3 10 9 6"></polyline></svg>
            </button>
            
            <div class="absolute inset-0 flex items-center justify-center ui-ignore">
                <div id="timer-text" class="countdown ui-ignore"></div>
            </div>
        </div>

        <!-- 外部控制區域：文字與按鈕 -->
        <div class="controls-area space-y-4">
            <div id="instruction-text" class="text-sm font-bold text-[#c4a882] tracking-wide h-6">
                憑記憶畫出出現的方塊
            </div>
            
            <div id="feedback" class="text-xs font-bold text-[#a0845e] h-4"></div>

            <div class="pt-2">
                <!-- 開始按鈕 -->
                <button id="realStartBtn" class="btn-main">
                    開始挑戰
                </button>

                <!-- 提交與下一題 -->
                <div class="flex gap-3">
                    <button id="submitBtn" class="hidden btn-main">確認送出</button>
                    <button id="nextBtn" class="hidden w-full py-4 bg-[#231e19] text-[#e8ddd0] border border-[#3a3028] rounded-2xl text-xs font-bold uppercase tracking-widest">下一題</button>
                </div>
            </div>

            <div id="score-display" class="text-[10px] font-mono text-[#6b5e4e] uppercase tracking-widest pt-2">
                TOTAL SCORE: 0
            </div>
        </div>
    </div>

    <!-- 結算彈窗 -->
    <div id="resultModal" class="fixed inset-0 bg-black/95 hidden items-center justify-center z-[200] p-6">
        <div class="bg-[#231e19] p-10 rounded-[2.5rem] border border-[#c4a882] text-center w-full max-w-xs shadow-2xl">
            <p class="text-[10px] uppercase tracking-widest text-[#9e8c78] mb-2">Final Score</p>
            <h2 id="finalScore" class="text-7xl font-black text-[#c4a882] mb-4">0</h2>
            <p id="finalComment" class="text-white/80 mb-10 font-medium"></p>
            <button onclick="location.reload()" class="w-full py-4 bg-[#c4a882] text-[#1a1612] rounded-2xl font-black uppercase tracking-tighter hover:bg-white transition-colors">
                再次挑戰
            </button>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const timerText = document.getElementById('timer-text');
        const statusText = document.getElementById('status-text');
        const instructionText = document.getElementById('instruction-text');
        const feedback = document.getElementById('feedback');
        const undoBtn = document.getElementById('undoBtn');
        const submitBtn = document.getElementById('submitBtn');
        const nextBtn = document.getElementById('nextBtn');
        const realStartBtn = document.getElementById('realStartBtn');
        const scoreDisplay = document.getElementById('score-display');

        let currentRound = 1;
        let totalScore = 0;
        let isDrawing = false;
        let userLines = []; 
        let currentLine = null;
        let targetBox = null; 
        let gameState = 'IDLE'; 
        let history = []; 

        function initCanvasSize() {
            const rect = canvas.getBoundingClientRect();
            canvas.width = rect.width;
            canvas.height = rect.height;
            render();
        }

        function render() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            if (targetBox && (gameState === 'OBSERVE' || gameState === 'REVIEW')) {
                ctx.save();
                ctx.strokeStyle = gameState === 'REVIEW' ? 'rgba(196, 168, 130, 0.4)' : '#ffffff';
                ctx.lineWidth = gameState === 'REVIEW' ? 2 : 3;
                if (gameState === 'REVIEW') ctx.setLineDash([5, 5]);
                
                const edges = [[0,1],[1,2],[2,3],[3,0],[4,5],[5,6],[6,7],[7,4],[0,4],[1,5],[2,6],[3,7]];
                edges.forEach(e => {
                    ctx.beginPath();
                    ctx.moveTo(targetBox.points[e[0]].x, targetBox.points[e[0]].y);
                    ctx.lineTo(targetBox.points[e[1]].x, targetBox.points[e[1]].y);
                    ctx.stroke();
                });
                ctx.restore();
            }

            ctx.strokeStyle = '#e8ddd0';
            ctx.lineWidth = 4;
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';
            
            userLines.forEach(l => {
                ctx.beginPath(); ctx.moveTo(l.x1, l.y1); ctx.lineTo(l.x2, l.y2); ctx.stroke();
            });
            if (currentLine) {
                ctx.beginPath(); ctx.moveTo(currentLine.x1, currentLine.y1); ctx.lineTo(currentLine.x2, currentLine.y2); ctx.stroke();
            }
        }

        realStartBtn.onclick = () => {
            realStartBtn.classList.add('hidden');
            undoBtn.classList.remove('hidden');
            startRound();
        };

        function startRound() {
            userLines = []; history = []; currentLine = null;
            gameState = 'OBSERVE';
            initCanvasSize();
            
            const size = canvas.width * (0.3 + Math.random() * 0.1);
            const cx = canvas.width / 2;
            const cy = canvas.height / 2;
            const pts = [];
            const angle = Math.random() * Math.PI * 2;
            const p = 0.35;

            for(let i=0; i<4; i++){
                const a = angle + i * Math.PI/2;
                pts.push({ x: cx + Math.cos(a)*size/1.5, y: cy + Math.sin(a)*size/1.5 });
            }
            for(let i=0; i<4; i++){
                pts.push({ x: pts[i].x + size*p, y: pts[i].y - size*p });
            }
            targetBox = { points: pts, size };
            
            // 修改處：移除動態更改 statusText 的代碼，讓它保持靜態
            instructionText.innerText = "記住方塊的位置與形狀";
            let count = 3;
            timerText.innerText = count;
            render();

            const timer = setInterval(() => {
                count--;
                if(count > 0) {
                    timerText.innerText = count;
                } else {
                    clearInterval(timer);
                    timerText.innerText = "";
                    gameState = 'DRAW';
                    instructionText.innerText = "憑記憶畫出剛剛的方塊";
                    undoBtn.disabled = false;
                    submitBtn.classList.remove('hidden');
                    render();
                }
            }, 1000);
        }

        function getMousePos(e) {
            const rect = canvas.getBoundingClientRect();
            const clientX = (e.touches ? e.touches[0].clientX : e.clientX);
            const clientY = (e.touches ? e.touches[0].clientY : e.clientY);
            return {
                x: (clientX - rect.left) * (canvas.width / rect.width),
                y: (clientY - rect.top) * (canvas.height / rect.height)
            };
        }

        const handleStart = (e) => {
            if(gameState !== 'DRAW') return;
            isDrawing = true;
            const pos = getMousePos(e);
            currentLine = { x1: pos.x, y1: pos.y, x2: pos.x, y2: pos.y };
            render();
        };

        const handleMove = (e) => {
            if(!isDrawing) return;
            const pos = getMousePos(e);
            currentLine.x2 = pos.x;
            currentLine.y2 = pos.y;
            render();
        };

        const handleEnd = () => {
            if(!isDrawing) return;
            isDrawing = false;
            if(currentLine) {
                const dist = Math.hypot(currentLine.x1 - currentLine.x2, currentLine.y1 - currentLine.y2);
                if(dist > 5) {
                    history.push([...userLines]);
                    userLines.push(currentLine);
                }
            }
            currentLine = null;
            render();
        };

        canvas.addEventListener('mousedown', handleStart);
        window.addEventListener('mousemove', handleMove);
        window.addEventListener('mouseup', handleEnd);
        canvas.addEventListener('touchstart', (e) => { e.preventDefault(); handleStart(e); }, {passive: false});
        window.addEventListener('touchmove', (e) => { e.preventDefault(); handleMove(e); }, {passive: false});
        window.addEventListener('touchend', handleEnd);

        undoBtn.onclick = (e) => {
            if(history.length > 0) {
                userLines = history.pop();
                render();
            }
        };

        submitBtn.onclick = () => {
            if(userLines.length === 0) return;
            gameState = 'REVIEW';
            submitBtn.classList.add('hidden');
            undoBtn.disabled = true;
            
            const score = calculateScore();
            totalScore += score;
            scoreDisplay.innerText = `TOTAL SCORE: ${Math.round(totalScore)}`;
            feedback.innerText = `本回合得分：${score}`;
            
            if(currentRound < 5) {
                nextBtn.classList.remove('hidden');
            } else {
                setTimeout(showFinal, 1000);
            }
            render();
        };

        nextBtn.onclick = () => {
            currentRound++;
            document.getElementById('round-display').innerText = `ROUND ${currentRound} / 5`;
            nextBtn.classList.add('hidden');
            startRound();
        };

        function calculateScore() {
            if(!targetBox || userLines.length === 0) return 0;
            let matchCount = 0;
            const targetPoints = targetBox.points;
            
            userLines.forEach(line => {
                let p1Match = targetPoints.some(tp => Math.hypot(line.x1 - tp.x, line.y1 - tp.y) < 30);
                let p2Match = targetPoints.some(tp => Math.hypot(line.x2 - tp.x, line.y2 - tp.y) < 30);
                if(p1Match && p2Match) matchCount++;
            });

            let final = Math.min(100, Math.round((matchCount / 12) * 100) + 20);
            if(userLines.length < 8) final = Math.round(final * 0.5);
            return final;
        }

        function showFinal() {
            document.getElementById('resultModal').style.display = 'flex';
            document.getElementById('finalScore').innerText = Math.round(totalScore);
            document.getElementById('finalComment').innerText = totalScore > 400 ? "你的空間記憶力簡直是天才級別！" : "很棒的嘗試，多練習幾次會更強！";
        }

        window.onresize = initCanvasSize;
        window.onload = initCanvasSize;
    </script>
</body>
</html>