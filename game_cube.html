<!DOCTYPE html>
<html lang="zh-Hant">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>小方塊大挑戰 - 記憶練習</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;600;800&display=swap');

        :root {
            --bg:        #1a1612;
            --surface:   #231e19;
            --border:    #3a3028;
            --muted:     #6b5e4e;
            --label:     #9e8c78;
            --text:      #e8ddd0;
            --accent:    #c4a882;
            --accent-dk: #a0845e;
            --canvas-bg: #1a2e1a; 
        }

        body {
            font-family: 'Inter', 'PingFang TC', sans-serif;
            background-color: var(--bg);
            color: var(--text);
            overflow-x: hidden;
            /* 修正：移除 touch-action: none，允許頁面捲動 */
            margin: 0;
            padding: 0;
            min-height: 100vh;
        }

        .global-nav {
            width: 100%;
            background-color: var(--surface);
            padding: 0.75rem;
            border-bottom: 1px solid var(--border);
        }
        .global-nav ul {
            display: flex;
            justify-content: center;
            gap: 1.5rem;
            list-style: none;
        }
        .global-nav a {
            color: var(--label);
            text-decoration: none;
            font-size: 0.75rem;
            font-weight: 600;
        }

        #canvas-container {
            position: relative;
            width: 90vw;
            height: 90vw;
            max-width: 400px;
            max-height: 400px;
            margin: 1.5rem auto;
            border-radius: 2rem;
            background-color: var(--canvas-bg);
            border: 2px solid var(--border);
            box-shadow: 0 20px 50px rgba(0,0,0,0.5);
            /* 修正：確保容器內觸摸不會導致頁面跳動 */
            touch-action: none;
        }

        canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 10;
            border-radius: 1.8rem;
            display: block;
            /* 修正：僅在畫布上禁用觸控手勢，防止繪圖時捲動 */
            touch-action: none;
        }

        #undoBtn {
            position: absolute;
            top: 12px;
            right: 12px;
            width: 40px;
            height: 40px;
            background-color: rgba(35, 30, 25, 0.8);
            color: var(--text);
            border: 1px solid var(--border);
            border-radius: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 20;
            transition: all 0.2s;
        }
        #undoBtn:disabled {
            opacity: 0;
            pointer-events: none;
        }

        .countdown {
            position: absolute;
            font-size: 8rem;
            color: var(--accent);
            opacity: 0.8;
            font-weight: 800;
            z-index: 5;
            pointer-events: none;
            text-shadow: 0 4px 20px rgba(0,0,0,0.3);
        }

        .controls-area {
            width: 100%;
            max-width: 380px;
            margin: 0 auto;
            padding: 0 1rem 3rem 1rem; /* 增加底部間距方便捲動 */
            text-align: center;
        }

        .btn-main {
            background-color: var(--accent-dk);
            color: var(--bg);
            font-weight: 800;
            border-radius: 1rem;
            padding: 1.25rem;
            width: 100%;
            transition: all 0.2s;
            text-transform: uppercase;
            letter-spacing: 0.1em;
            cursor: pointer;
        }
        .btn-main:active {
            transform: scale(0.98);
            background-color: var(--accent);
        }
    </style>
</head>
<body class="flex flex-col items-center">
   
<div id="nav" class="w-full"></div>
<script>
  const NAV_FALLBACK = `
    <nav class="global-nav">
      <ul>
        <li><a href="#">首頁</a></li>
      </ul>
    </nav>`;

  function initNav(html) {
    const navContainer = document.getElementById('nav');
    navContainer.innerHTML = html;
  }

  // 模擬載入，實際環境會 fetch
  initNav(NAV_FALLBACK);
</script>

    <div class="w-full max-w-md px-4 py-4 flex flex-col items-center">
        <header class="w-full flex justify-between items-end mb-2 px-2">
            <div>
                <h1 class="text-xl font-black tracking-tight">小方塊<span class="text-[#c4a882]">大挑戰</span></h1>
                <p id="status-text" class="text-[10px] uppercase font-bold tracking-widest text-[#9e8c78]">方塊畫的好.畫畫沒煩惱</p>
            </div>
            <div id="round-display" class="px-3 py-1 rounded-full text-[10px] border border-[#3a3028] bg-[#231e19] text-[#c4a882] font-mono">ROUND 1 / 5</div>
        </header>

        <div id="canvas-container">
            <canvas id="gameCanvas"></canvas>
            <button id="undoBtn" class="hidden" disabled>
                <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3" stroke-linecap="round" stroke-linejoin="round"><path d="M3 10h10a8 8 0 0 1 8 8v2"></path><polyline points="9 14 3 10 9 6"></polyline></svg>
            </button>
            <div class="absolute inset-0 flex items-center justify-center pointer-events-none">
                <div id="timer-text" class="countdown"></div>
            </div>
        </div>

        <div class="controls-area space-y-4">
            <div id="instruction-text" class="text-sm font-bold text-[#c4a882] tracking-wide h-6">
                準備好開始挑戰了嗎？
            </div>
            <div id="feedback" class="text-xs font-bold text-[#a0845e] h-4"></div>

            <div class="pt-2">
                <button id="realStartBtn" class="btn-main">開始挑戰</button>
                <div class="flex flex-col gap-3">
                    <button id="submitBtn" class="hidden btn-main">確認送出</button>
                    <button id="nextBtn" class="hidden w-full py-4 bg-[#231e19] text-[#e8ddd0] border border-[#3a3028] rounded-2xl text-xs font-bold uppercase tracking-widest">下一題</button>
                </div>
            </div>

            <div id="score-display" class="text-[10px] font-mono text-[#6b5e4e] uppercase tracking-widest pt-2">
                TOTAL SCORE: 0
            </div>
        </div>
    </div>

    <div id="resultModal" class="fixed inset-0 bg-black/95 hidden items-center justify-center z-[200] p-6">
        <div class="bg-[#231e19] p-10 rounded-[2.5rem] border border-[#c4a882] text-center w-full max-w-xs shadow-2xl">
            <p class="text-[10px] uppercase tracking-widest text-[#9e8c78] mb-2">Final Score</p>
            <h2 id="finalScore" class="text-7xl font-black text-[#c4a882] mb-4">0</h2>
            <p id="finalComment" class="text-white/80 mb-10 font-medium"></p>
            <button onclick="location.reload()" class="w-full py-4 bg-[#c4a882] text-[#1a1612] rounded-2xl font-black uppercase tracking-tighter hover:bg-white transition-colors">
                再次挑戰
            </button>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const timerText = document.getElementById('timer-text');
        const instructionText = document.getElementById('instruction-text');
        const feedback = document.getElementById('feedback');
        const undoBtn = document.getElementById('undoBtn');
        const submitBtn = document.getElementById('submitBtn');
        const nextBtn = document.getElementById('nextBtn');
        const realStartBtn = document.getElementById('realStartBtn');
        const scoreDisplay = document.getElementById('score-display');

        let currentRound = 1;
        let totalScore = 0;
        let isDrawing = false;
        let userLines = []; 
        let currentLine = null;
        let targetBox = null; 
        let gameState = 'IDLE'; 
        let history = []; 

        const cubePoints = [
            [-1, -1,  1], [ 1, -1,  1], [ 1,  1,  1], [-1,  1,  1],
            [-1, -1, -1], [ 1, -1, -1], [ 1,  1, -1], [-1,  1, -1]
        ];
        const cubeEdges = [
            [0,1], [1,2], [2,3], [3,0], [4,5], [5,6], [6,7], [7,4], [0,4], [1,5], [2,6], [3,7]
        ];

        function initCanvasSize() {
            const rect = canvas.getBoundingClientRect();
            canvas.width = rect.width * window.devicePixelRatio;
            canvas.height = rect.height * window.devicePixelRatio;
            ctx.scale(window.devicePixelRatio, window.devicePixelRatio);
            render();
        }

        function project(points3d, rotateX, rotateY, rotateZ, scale, cx, cy) {
            return points3d.map(p => {
                let x = p[0], y = p[1], z = p[2];
                let x1 = x * Math.cos(rotateY) - z * Math.sin(rotateY);
                let z1 = x * Math.sin(rotateY) + z * Math.cos(rotateY);
                let y2 = y * Math.cos(rotateX) - z1 * Math.sin(rotateX);
                let z2 = y * Math.sin(rotateX) + z1 * Math.cos(rotateX);
                let x3 = x1 * Math.cos(rotateZ) - y2 * Math.sin(rotateZ);
                let y3 = x1 * Math.sin(rotateZ) + y2 * Math.cos(rotateZ);
                let fov = 500;
                let factor = fov / (fov + z2);
                return { x: cx + x3 * factor * scale, y: cy + y3 * factor * scale };
            });
        }

        function render() {
            const w = canvas.width / window.devicePixelRatio;
            const h = canvas.height / window.devicePixelRatio;
            ctx.clearRect(0, 0, w, h);
            
            if (targetBox && (gameState === 'OBSERVE' || gameState === 'REVIEW')) {
                ctx.save();
                ctx.strokeStyle = gameState === 'REVIEW' ? 'rgba(196, 168, 130, 0.4)' : '#ffffff';
                ctx.lineWidth = gameState === 'REVIEW' ? 2 : 3;
                if (gameState === 'REVIEW') ctx.setLineDash([5, 5]);
                
                targetBox.edges.forEach(e => {
                    ctx.beginPath();
                    ctx.moveTo(targetBox.pts[e[0]].x, targetBox.pts[e[0]].y);
                    ctx.lineTo(targetBox.pts[e[1]].x, targetBox.pts[e[1]].y);
                    ctx.stroke();
                });
                ctx.restore();
            }

            ctx.strokeStyle = '#e8ddd0';
            ctx.lineWidth = 4;
            ctx.lineCap = 'round';
            userLines.forEach(l => {
                ctx.beginPath(); ctx.moveTo(l.x1, l.y1); ctx.lineTo(l.x2, l.y2); ctx.stroke();
            });
            if (currentLine) {
                ctx.beginPath(); ctx.moveTo(currentLine.x1, currentLine.y1); ctx.lineTo(currentLine.x2, currentLine.y2); ctx.stroke();
            }
        }

        realStartBtn.onclick = () => {
            realStartBtn.classList.add('hidden');
            undoBtn.classList.remove('hidden');
            startRound();
        };

        function startRound() {
            userLines = []; history = []; currentLine = null;
            gameState = 'OBSERVE';
            feedback.innerText = "";
            instructionText.innerText = "記住方塊的位置與形狀";
            
            const w = canvas.width / window.devicePixelRatio;
            const h = canvas.height / window.devicePixelRatio;
            const rx = (Math.random() - 0.5) * 1.5;
            const ry = (Math.random() - 0.5) * 1.5;
            const rz = (Math.random() - 0.5) * 1.5;
            const scale = w * 0.25; 

            targetBox = { 
                pts: project(cubePoints, rx, ry, rz, scale, w/2, h/2), 
                edges: cubeEdges 
            };
            
            let count = 3;
            timerText.innerText = count;
            render();

            const timer = setInterval(() => {
                count--;
                if(count > 0) {
                    timerText.innerText = count;
                } else {
                    clearInterval(timer);
                    timerText.innerText = "";
                    gameState = 'DRAW';
                    instructionText.innerText = "憑記憶畫出剛剛的方塊 ";
                    undoBtn.disabled = false;
                    submitBtn.classList.remove('hidden');
                    render();
                }
            }, 1000);
        }

        function getMousePos(e) {
            const rect = canvas.getBoundingClientRect();
            const clientX = (e.touches ? e.touches[0].clientX : e.clientX);
            const clientY = (e.touches ? e.touches[0].clientY : e.clientY);
            return { x: clientX - rect.left, y: clientY - rect.top };
        }

        const handleStart = (e) => {
            if(gameState !== 'DRAW') return;
            isDrawing = true;
            const pos = getMousePos(e);
            currentLine = { x1: pos.x, y1: pos.y, x2: pos.x, y2: pos.y };
            render();
        };

        const handleMove = (e) => {
            if(!isDrawing) return;
            const pos = getMousePos(e);
            currentLine.x2 = pos.x;
            currentLine.y2 = pos.y;
            render();
        };

        const handleEnd = () => {
            if(!isDrawing) return;
            isDrawing = false;
            if(currentLine) {
                const d = Math.hypot(currentLine.x1 - currentLine.x2, currentLine.y1 - currentLine.y2);
                if(d > 10) {
                    history.push([...userLines]);
                    userLines.push(currentLine);
                }
            }
            currentLine = null;
            render();
        };

        // 桌面端事件
        canvas.addEventListener('mousedown', handleStart);
        window.addEventListener('mousemove', handleMove);
        window.addEventListener('mouseup', handleEnd);

        // 行動端事件：僅在 canvas 區域內攔截預設行為（防止捲動），在其他區域則允許預設行為
        canvas.addEventListener('touchstart', (e) => { 
            if(gameState === 'DRAW') {
                e.preventDefault(); 
                handleStart(e); 
            }
        }, {passive: false});
        
        canvas.addEventListener('touchmove', (e) => { 
            if(gameState === 'DRAW' && isDrawing) {
                e.preventDefault(); 
                handleMove(e); 
            }
        }, {passive: false});
        
        canvas.addEventListener('touchend', (e) => {
            if(gameState === 'DRAW') {
                handleEnd();
            }
        });

        undoBtn.onclick = () => {
            if(history.length > 0) {
                userLines = history.pop();
                render();
            }
        };

        submitBtn.onclick = () => {
            if(userLines.length < 3) return;
            gameState = 'REVIEW';
            submitBtn.classList.add('hidden');
            undoBtn.disabled = true;
            
            const score = calculateScore();
            totalScore += score;
            scoreDisplay.innerText = `TOTAL SCORE: ${totalScore}`;
            feedback.innerText = `本回合得分：${score}`;
            
            if(currentRound < 5) nextBtn.classList.remove('hidden');
            else setTimeout(showFinal, 1200);
            render();
        };

        nextBtn.onclick = () => {
            currentRound++;
            document.getElementById('round-display').innerText = `ROUND ${currentRound} / 5`;
            nextBtn.classList.add('hidden');
            startRound();
        };

        function calculateScore() {
            if(!targetBox || userLines.length === 0) return 0;
            const targetEdges = targetBox.edges.map(e => ({ p1: targetBox.pts[e[0]], p2: targetBox.pts[e[1]] }));
            let totalAcc = 0, matchedCount = 0, usedUserLines = new Set();

            targetEdges.forEach(te => {
                let bestMatchScore = 0, bestIdx = -1;
                userLines.forEach((ul, uIdx) => {
                    if (usedUserLines.has(uIdx)) return;
                    const d1 = Math.hypot(ul.x1 - te.p1.x, ul.y1 - te.p1.y) + Math.hypot(ul.x2 - te.p2.x, ul.y2 - te.p2.y);
                    const d2 = Math.hypot(ul.x1 - te.p2.x, ul.y1 - te.p2.y) + Math.hypot(ul.x2 - te.p1.x, ul.y2 - te.p1.y);
                    const minD = Math.min(d1, d2);
                    const angleT = Math.atan2(te.p2.y - te.p1.y, te.p2.x - te.p1.x);
                    const angleU = Math.atan2(ul.y2 - ul.y1, ul.x2 - ul.x1);
                    let angleDiff = Math.abs(angleT - angleU) % Math.PI;
                    if (angleDiff > Math.PI / 2) angleDiff = Math.PI - angleDiff;

                    if (minD < 100 && angleDiff < 0.5) {
                        const distScore = Math.max(0, 1 - minD / 100);
                        const angleScore = Math.max(0, 1 - angleDiff / 0.5);
                        const currentScore = (distScore * 0.6 + angleScore * 0.4) * 100;
                        if (currentScore > bestMatchScore) { bestMatchScore = currentScore; bestIdx = uIdx; }
                    }
                });
                if (bestMatchScore > 40) { totalAcc += bestMatchScore; matchedCount++; usedUserLines.add(bestIdx); }
            });

            const coverage = (matchedCount / 12);
            const precision = matchedCount > 0 ? (totalAcc / matchedCount) / 100 : 0;
            const clutterPenalty = Math.max(0.6, 1 - Math.max(0, userLines.length - 15) * 0.04);
            return Math.min(100, Math.round((coverage * 80 + precision * 20) * clutterPenalty));
        }

        function showFinal() {
            document.getElementById('resultModal').style.display = 'flex';
            document.getElementById('finalScore').innerText = totalScore;
            
            let comment = "";
            if (totalScore >= 450) comment = "神一般的空間感！大腦內建3D建模！";
            else if (totalScore >= 350) comment = "記憶力與透視感都相當驚人。";
            else if (totalScore >= 250) comment = "表現不錯，方塊畫得很紮實";
            else if (totalScore >= 150) comment = "進步空間很大，多練習觀察方塊！";
            else comment = "你需要多多練習！";
            
            document.getElementById('finalComment').innerText = comment;
        }

        window.onresize = initCanvasSize;
        window.onload = initCanvasSize;
    </script>
</body>
</html>